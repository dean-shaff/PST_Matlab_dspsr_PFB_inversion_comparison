## PST_Matlab_dspsr_PFB_inversion_comparison

Compare the results of dspsr's PFB inversion implementation to the PST Signal model,
implemented in Matlab. The goal of this comparison is to assess whether the two
implementations produce the same results, within numerical precision.

Attempting to abide by the Matlab coding conventions enumerated [here](https://au.mathworks.com/matlabcentral/fileexchange/46056-matlab-style-guidelines-2-0).

Function documentation using [jsdoc](http://usejsdoc.org/) style documentation.

### Installation

This repo uses Python to process test vectors generated by a Matlab pipeline.

With [poetry](https://poetry.eustace.io/docs/) installed:

```
cd python
poetry install
```

### Usage

Normal usage would consist of creating test vectors, and then processing them
with dspsr before comparing the results of dspsr's PFB inversion with that
of the model. In Matlab:

```matlab
>>> pipeline  % wait a while
```

From the command line:

```bash
me@local:/path/to/repo$ cd python
me@local:/path/to/repo/python$ poetry run python process_test_vectors.py -bd ./../data/test_vectors
me@local:/path/to/repo/python$ poetry run python compare_dump_files.py -i ./../data/test_vectors/freq/f-0.100_b-0.100_p-0.785/complex_sinusoid.dump ./../data/test_vectors/freq/f-0.100_b-0.100_p-0.785/pre_Detection.polyphase_analysis_alt.complex_sinusoid.dump ./../data/test_vectors/freq/f-0.100_b-0.100_p-0.785/polyphase_synthesis.complex_sinusoid.dump -fft 4096 -t 0,1000 -p 0 -n
```

The last command will compare the the original complex sinusoid, the result
from dspsr's inversion, and the result from the Matlab inversion implementation.

Alternative usage consists of using matlab executables to generate test vectors,
channelize data, or synthesize data on the fly.

Generating a dual polarization complex sinuosoid:

```bash
./build/generate_test_vector complex_sinusoid 1000 0.01,0.5,0.1 single 1 config/default_header.json test_complex_sinusoid.dump ./ 1
```

Generating a dual polarization time domain impulse of width 50:

```bash
./build/generate_test_vector time_domain_impulse 1000 0.01,50 single 2 config/default_header.json test_time_domain_impulse.dump ./ 1
```

Channelizing some data:

```bash
./build/channelize ./data/test_vectors/time/o-0.010_w-1.000/time_domain_impulse.dump 8 8/7 config/OS_Prototype_FIR_8.mat test.channelized.time_domain_impulse.dump ./data/test_vectors/time/o-0.010_w-1.000/ 1
```

Synthesizing data:

```bash
./build/synthesize ./data/test_vectors/time/o-0.010_w-1.000/polyphase_analysis_alt.time_domain_impulse.dump 16384 test_synthesis.dump ./data/test_vectors/time/o-0.010_w-1.000/ 1
```


The following is a list of the files in the repo, and a brief description
of what they do.

- `single_double_fft.m`: Determines if matlab's `fft` returns an array whose data
type is the same a that of the input. This also produces a plot displaying the
numerical difference between the input arrays and the results of applying
the `fft` function to each of the input arrays. The motivation for this script
comes from the fact that Numpy's FFT implementation does not return the same
datatype for single precision inputs:

```python
>>> import numpy as np
>>> a = np.random.rand(1024, dtype=np.float32)
>>> f = np.fft.fft(a)
>>> print(f.dtype)
complex128
```

If Numpy's FFT were datatype consistent, the above example should output `complex64`.
Moreover, we can see that Numpy actually implicitly upcasts 32 bit data when
calling `numpy.fft.fft`:

```python
>>> import numpy as np
>>> a32 = np.random.rand(1024, dtype=np.float32)
>>> a64 = a32.astype(np.float64)
>>> f32 = np.fft.fft(a32) # not actually 32-bit data!
>>> f64 = np.fft.fft(a64)
>>> np.sum(np.abs(f32 - f64))
0
```

If Numpy were actually computing a 32-bit FFT, we would see some numerical
difference between `f32` and `f64` even though the inputs are attempting to
represent the same array of numbers. This is actually a known bug in Numpy:
https://github.com/numpy/numpy/issues/6012

- `write_header.m`: Writes a DADA header to an open file
- `read_header.m`: Reads a DADA header from an open file
- `load_file.m`: Create a file handler, and then pass it to a callback before
closing the file. Return whatever the callback returned.
- `save_file.m`: Create a file handler, and then pass it to a callback before
closing the file. Can pass arguments to the callback.
- `read_fir_filter_coeff.m`: Read in FIR filter coefficents from a matlab
`.mat` file.
- `struct2map.m`: Convert a `struct` object to a `containers.Map` object.
- `normalize.m`: Normalize an integer given some oversampling factor struct.
- `compare_dump_files.m`: Compare two dump files. Prefer the Python version,
as it has many more features and a cleaner interface.
- `channelize.m`: Channelize some data from a given file. Save the output.
- `synthesize.m`: Apply PFB inversion to the data in a given file. Save the
output.
- `test.m`: Run all the test commands.
- `pad_filter.m`: Zero pad the start of an FIR filter.
- `polyphase_analysis.m`: Implements polyphase filterbank algorithm.
This is originally John Bunton's code with some (small) modifications to incorporate
`os_factor` structs.
- `polyphase_analysis_alt.m`: Implements polyphase filterbank algorithm using
an alternative algorithm. This is based on code written by Ian Morrison and
Thushara Kanchana Gunaratne.
- `polyphase_synthesis.m`: Implements polyphase filterbank inversion algorithm.
- `polyphase_synthesis_alt.m`: Implements polyphase filterbank inversion algorithm.
The purpose of this function is to exactly implement the PFB inversion algorithm
used in Ian Morrison's PST spectral and temporal purity [tests](https://github.com/SKA-PST/PST_Matlab_channelizer_inverter_purity_measurement_CDR).
- `time_domain_impulse.m`: Generates a time domain impulse. Can generate
multiple impulses of varying widths.
- `complex_sinusoid.m`: Generate a complex sinusoid at a given frequency. Can
also generate a linear combination of sinusoids at any number of specified
frequencies.
- `pipeline.m`: Run the test vector generation, analysis and synthesis pipeline.
This will create a directory structure in the `data` subdirectory.

### Testing

Run `test.m` to run a basic suite of unit-like tests.
